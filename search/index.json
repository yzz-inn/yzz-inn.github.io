[{"content":"hugo配置 1.下载pcre（yum下载的会出错，直接源码下载) 1 2 3 4 5 6 7 8 9 sudo wget http://downloads.sourceforge.net/project/pcre/pcre/8.45/pcre-8.45.tar.gz tar -zxvf pcre-8.45.tar.gz.2 -C /usr/local/ //解压到指定目录 cd /usr/local/pcre-8.45 ./configure cd .. sudo chmod -R 777 pcre-8.45 //给读写执行权限 sudo chmod -R 777 nginx cd pcre-8.45 sudo make \u0026amp;\u0026amp; make install //安装并编译 2.安装nginx 安装依赖软件 1 sudo yum install -y gcc gcc-c++ zlib zlib-devel openssl openssl-devel 下载源码 1 2 wget http://nginx.org/download/nginx-1.22.1.tar.gz sudo tar -zxvf nginx-1.22.1.tar.gz -C /usr/local/ 进入安装目录，进行编译配置安装 1 2 3 cd /usr/local/nginx-1.22.1 ./configure --user=nginx --group=nginx --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module --with-pcre=/usr/local/pcre-8.45 //配置 sudo make \u0026amp;\u0026amp; make install 启动时报错：没有error.log access.log文件，返回创建 1 2 3 sudo mkdir logs cd logs sudo touch error.log access.log 进入安装目录，启动Nginx 1 2 3 cd /usr/local/nginx/sbin ./nginx ps aux | grep nginx //查看Nginx进程，确认启动成功 3.HUGO配置 (1)安装go 1 2 sudo wget https://go.dev/dl/go1.19.4.linux-amd64.tar.gz sudo tar -zxvf go1.19.4.linux-amd64.tar.gz -C /usr/local (2)下载hugo 1 2 sudo wget https://github.com/gohugoio/hugo/releases/download/v0.108.0/hugo_0.108.0_Linux-64bit.tar.gz sudo tar -zxvf hugo_0.108.0_Linux-64bit.tar.gz -C /usr/local/hugo (3)配置环境变量 sudo vim /etc/profile source /etc/profile sudo cp -a /usr/local/hugo /usr/local/bin //复制一份到/usr/local/bin，不然hugo执行找不到路径 (4)查看版本 1 hugo version (5)报错，发现是libstdc++版本过低，下载个新的版本 1 2 3 4 5 6 7 sudo wget http://www.vuln.cn/wp-content/uploads/2019/08/libstdc.so_.6.0.26.zip //下载 sudo unzip libstdc.so_.6.0.26.zip -d /usr/lib64 //解压 cd /usr/lib64 //进入目录 chmod 755 libstdc++.so.6.0.26 //修改文件权限 sudo mv libstdc++.so.6 libstdc++.so.6-bak //备份原libstdc++.so.6软连接 sudo ln -s libstdc++.so.6.0.26 libstdc++.so.6 //创建新的软连接，连接到新的库即可 ll libstd* //查看 (6)开启httpd，并添加1313端口 1 2 3 4 5 6 7 8 sudo yum install -y httpd //下载httpd sudo yum install -y firewall-config //系统自带firewalld，但没有这个 systemctl start httpd systemctl status httpd sudo firewall-cmd --add-service=http --permanent sudo firewall-cmd --add-port=1313/tcp --permanent //添加端口 sudo firewall-cmd --reload //防火墙重新加载配置 sudo firewall-cmd --list-ports //查看开放端口 (7)接着继续配置网站 1 2 3 4 5 6 hugo new site y-blog //新建网站 cd /y-blog/themes git clone https://github.com/CaiJimmy/hugo-theme-stack.git //添加主题 //启动hugo服务器 hugo server -t hugo-theme-stack --buildDrafts --bind=\u0026#34;0.0.0.0\u0026#34; --baseURL=http:192.168.56.101:1313/ hugo new posts/linux-study.md //接着就进入content/posts用markdown编写 启动成功\n4.部署到github 1 2 3 4 5 6 hugo --theme=hugo-theme-stack --baseURL=https://yzz-inn.github.io/ //执行，生成public目录 git init git remote add origin https://github.com/yzz-inn/yzz-inn.github.io.git git add -A git commit -m \u0026#34;ll\u0026#34; git push -u origin master ","date":"2022-12-11T00:00:00Z","image":"https://yzz-inn.github.io/p/linux-study3/matt-le-SJSpo9hQf7s-unsplash_hu958d513eeefe5556a31d065479ecc5ac_14205_120x120_fill_q75_box_smart1.jpg","permalink":"https://yzz-inn.github.io/p/linux-study3/","title":"Linux-study(3)"},{"content":"本篇博客主要介绍git安装配置，并部署到Gitee上的操作\ngit安装配置 一、安装git 1.git源码下载，并解压到/usr/local目录去\n1 2 wget https://github.com/git/git/archive/refs/tags/v2.35.1.tar.gz sudo tar -xzvf v2.35.1.tar.gz -C /usr/local/ 2.安装依赖\n1 sudo yum install curl-devel gettext-devel openssl-devel zlib-devel perl-ExtUtils-MakeMaker gcc expat-devel 3.在源码所在目录下编译安装\n1 2 3 cd /usr/local/git-2.35.1 sudo make prefix=/usr/local/git all sudo make prefix=/usr/local/git install 4.配置环境变量\n1 2 3 sudo vim /etc/profile export PATH=\u0026#34;/usr/local/git/bin:$PATH\u0026#34; //进去/etc/profile配置 source /etc/profile //执行 5.查看版本，安装成功\n1 git --version 二、连接Gitee并上传文件 1.生成公钥\n1 ssh-keygen -t ed25519 -C \u0026#34;lll363214@163.com\u0026#34; \\\\连续回车三次即可获得公钥和私钥 2.查看并复制到Gitee进行公钥添加\n1 2 cat /home/yzz/.ssh/id_ed25519.pub ssh -T git@gitee.com //配置成功 3.配置用户信息\n1 2 git config -global user.name \u0026#34;Yinz\u0026#34; git config --global user.email \u0026#34;lll363214@163.com\u0026#34; 4.创建仓库并上传文件\n1 2 3 4 5 6 7 8 9 #创建本地仓库 mkdir lnote cd lnote git init //初始化仓库 touch README.md git add README.md //添加文件 git commit -m \u0026#34;first commit\u0026#34; //提交文件 git remote add origin git@gitee.com:l-yine/lnote.git git push -u origin \u0026#34;master\u0026#34; ","date":"2022-12-10T00:00:00Z","image":"https://yzz-inn.github.io/p/linux-study1/pawel-czerwinski-8uZPynIu-rQ-unsplash_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://yzz-inn.github.io/p/linux-study1/","title":"Linux-study(1)"},{"content":" Socket是在应用层和传输层之间的一个抽象层，它把TCP/IP层复杂的操作抽象为几个简单的接口，供应用层调用实现进程在网络中的通信。Socket保证了不同计算机之间的通信，也就是网络通信。\nsocket 通信传递 server.cpp服务端 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;netinet/in.h\u0026gt; #idefine PORT 6666 #define BACKLOG 10 #define MAX_SIZE 2048 int main() { int socket_fd; //定义服务器socket的描述符 struct sockaddr_in server_addr; //定义套接字的地址形式 char buffer[MAX_SIZE]={0}; char message[MAX_SIZE]; socket_fd = socket(AF_INET,SOCK_STREAM,0); bzero(\u0026amp;server_addr,sizeof(server_addr)); //清零字节 server_addr.sin_family = AF_INET; server_addr.sin_port=htons(PORT); server_addr.sin_addr.s_addr = INADDR_ANY; bind(socket_fd,(struct sockaddr *)\u0026amp;server_addr,sizeof(server_addr)); //绑定端口 listen(socket_fd,BACKLOG); //开始监听 printf(\u0026#34;Server bind success \\n\u0026#34;); //定义客户端socket struct sockaddr_in peer_addr; socklen_t peer_len = sizeof(peer_addr); while(1) { int client_fd; client_fd = accept(socket_fd,(struct sockaddr* )\u0026amp;peer_addr,\u0026amp;peer_len); printf(\u0026#34;Receive a connect from clinet fd[%d,ip:%s,port:%d]\\n\u0026#34;, client_fd,inet_ntoa(peer_addr.sin_addr),ntohs(peer_addr.sin_port)); while (1) { memset(buffer,0,sizeof(buffer)); int recv_len = recv(client_fd,buffer,MAX_SIZE,0); if(recv_len == 0) { printf(\u0026#34;Clinet is already closed\\n\u0026#34;); break; } else { printf(\u0026#34;Recv len is %d \\n\u0026#34;,recv_len); } printf(\u0026#34;Clinet says:\\n\u0026#34;); strcpy(message,buffer); fputs(message,stdout); memset(buffer,0,MAX_SIZE); printf(\u0026#34;Please input:\\n\u0026#34;); fgets(buffer,sizeof(buffer),stdin); send(client_fd,buffer,recv_len,0); } close(client_fd); break; } close(socket_fd); return 0; } client.cpp 客户端 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;netinet/in.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; #define CLIETN_PORT 6666 #define MAX_SIZE 2048 int main(int argc, char *argv[]) { if (argc != 2) { printf(\u0026#34;Please input server ip\\n\u0026#34;); exit(1); } char buffer[MAX_SIZE]; //建立 int socket_fd = socket(AF_INET, SOCK_STREAM, 0); const char *server_ip = argv[1]; struct sockaddr_in server_addr; bzero(\u0026amp;server_addr, sizeof(server_addr)); server_addr.sin_family = AF_INET; server_addr.sin_port = htons(CLIETN_PORT); inet_pton(AF_INET, server_ip, \u0026amp;server_addr.sin_addr); connect(socket_fd, (struct sockaddr *)\u0026amp;server_addr, sizeof(server_addr)); printf(\u0026#34;Connect to server success\\n\u0026#34;); memset(buffer, 0, MAX_SIZE); printf(\u0026#34;Please input:\\n\u0026#34;); while (fgets(buffer, sizeof(buffer), stdin) != NULL) { if (strncmp(buffer, \u0026#34;quit\u0026#34;, 4) == 0) { printf(\u0026#34;intpu is: quit break\\n\u0026#34;); break; } else { printf(\u0026#34;intpu is: %s\\n\u0026#34;, buffer); } send(socket_fd, buffer, strlen(buffer), 0); memset(buffer, 0, sizeof(buffer)); recv(socket_fd, buffer, sizeof(buffer), 0); printf(\u0026#34;Server says:\\n\u0026#34;); fputs(buffer, stdout); memset(buffer, 0, sizeof(buffer)); printf(\u0026#34;Please input:\\n\u0026#34;); } printf(\u0026#34;Client will be closed\\n\u0026#34;); close(socket_fd); return 0; } ","date":"2022-12-10T00:00:00Z","permalink":"https://yzz-inn.github.io/p/linux-study2/","title":"Linux-study(2)"},{"content":"文件系统命令 目录操作命令 pwd：显示当前工作目录的绝对路径 cd :更改工作目录路径 . :代表当前目录 .. :代表上一层目录 ~ :代表家目录 mkdir: 创建目录 rmdir:删除空目录 ls : 列出目录和文件信息 -l : 以详细信息的形式展示出当前目录的文件 -a ：显示当前目录中的全部文件 -d ：查看目录属性 -t ：按照创建时间顺序列出文件 -h : 与-l一起，以易于阅读的形式输出文件大小 文件操作命令 touch：创建空文件、更改文件时间 rm ：删除文件或目录（一般使用rm -rf删除目录） -f：强制删除，即使文件属性设为只读，也直接删除，无需逐一确认 -r：递归删除目录 cp ：复制文件或目录（例：cp -a /etc/example.md /usr/local //将etc目录下的example.md文件复制到/usr/local目录下） -a：通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容 mv ：改名、移动文件和目录\n通配符的使用 通配符 说明 例子 ？ 匹配任意一个字符 ls ?.txt（查询带.txt后缀的一个文件) * 匹配任意多个字符 ls *.txt（查询带.txt后缀的所有文件) [] 相当于或的意思 ls [abc].txt（查询带.txt后缀并且有任意一个abc字母的文件) - 代表一个范围，比如a-z ls [a-v].txt（查询带.txt后缀并且有任意一个a到v之间字母的文件) 文件内容操作命令 which：用来搜索二进制文件、可执行文件或者shell命令行的位置 cat：显示文件内容、连接文件内容（格式：cat 文件1 文件2 \u0026hellip;） head：显示指定文件的前若干行（格式：head -n 行数 文件） tail：查看文件末尾数据（格式： -n 行数 文件） find：查找文件或目录（格式：find [查找范围] [选项]) 选项 说明 例子 -name \u0026ldquo;文件名\u0026rdquo; 匹配文件的名称(支持通配符) find /usr/local -name \u0026ldquo;*.txt\u0026rdquo;（查找/usr/local目录下的.txt文件) -type \u0026lt;文件类型\u0026gt; 匹配文件类型查找（f表示普通文件，d表示目录） find /usr/local -type f（查找/usr/local目录下的普通文件) -size n[cKMG] 匹配文件的大小（+50k为查找超过50k的文件） find /usr/local -size +1M（查找目录下超过1M的文件） grep：搜索与字符串匹配的行（格式：grep \u0026lt;命令\u0026gt; [被搜索的字符串] [查找位置]） 通配符 说明 -i 查找时忽略大小写 -n 显示行号 -r 递归搜索子目录 -v 反转查找，输出与查找条件不相符的行 打包和解包 打包 打包 tar -czvf 打包文件名.tar.gz 源文件或目录 tar -cjvf 打包文件名.tar.bz2 源文件或目录 tar -cJvf 打包文件名.tar.xz 源文件或目录 解包 解包 tar -xzvf 打包文件名.tar.gz -C 解压目录 tar -xjvf 打包文件名.tar.bz2 -C 解压目录 tar -xJvf 打包文件名.tar.xz -C 解压目录 zip格式 安装：sudo yum install zip unzip 打包：zip -r 文件.zip 源文件或目录（-r：表示递归打包目录） 解包：unzip 文件.zip -d 解压目录 链接 软链接（格式：ln -s 源文件 目标文件) 符号链接等价与建立了快捷方式。符号链接原文件被删除时，链接文件将失效；如果重新给一个同路径同名文件，链接文件又会恢复。\n硬链接（格式：ln 源文件 目标文件） 链接文件和被链接文件必须位于同一个文件系统中，同时不能建立指向目录的硬链接。 硬链接文件对删除哪个都不影响对方，只是指定链接计数减少而已，减为0时文件才从硬盘消失。\n","date":"2022-12-10T00:00:00Z","image":"https://yzz-inn.github.io/p/other/the-creative-exchange-d2zvqp3fpro-unsplash_huf941de4769045cdfa8c9ee7036519a2a_35369_120x120_fill_q75_box_smart1.jpg","permalink":"https://yzz-inn.github.io/p/other/","title":"Other"}]